// api/all_tourism.js

const AREA_CODES = {
    'ì„œìš¸': 1, 'ë¶€ì‚°': 6, 'ì œì£¼': 39, 'ê°•ë¦‰': 32,
    'ì „ì£¼': 37, 'ëŒ€êµ¬': 4, 'ê´‘ì£¼': 5, 'ëŒ€ì „': 3,
    'ì¸ì²œ': 2, 'ìš¸ì‚°': 7, 'ê²½ì£¼': 35, 'ì¶˜ì²œ': 32
};

const CONTENT_TYPES = {
    festivals: 15,
    accommodation: 32,
    restaurants: 39,
    culture: 14,
    attractions: 12,
    all: 'all'
};

const API_CONFIG = {
    baseUrl: 'https://apis.data.go.kr/B551011/KorService2/areaBasedList2',
    timeout: 15000,
    maxRetries: 3,
    retryDelay: 1000,
    chunkSize: 20,
    maxItemsPerRequest: 100
};

const isDev = process.env.NODE_ENV === 'development';

export default async function handler(req, res) {
    // CORS ì„¤ì •
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    const startTime = Date.now();

    try {
        // ì…ë ¥ íŒŒë¼ë¯¸í„° ê²€ì¦ ë° ê¸°ë³¸ê°’ ì„¤ì •
        const validatedParams = validateAndParseParams(req.query);
        if (validatedParams.error) {
            return res.status(400).json({
                success: false,
                message: validatedParams.error,
                timestamp: new Date().toISOString()
            });
        }

        const { region, type, detail, numOfRows } = validatedParams;

        if (isDev) {
            console.log('ğŸš€ í†µí•© ê´€ê´‘ API ì‹œì‘');
            console.log(`ğŸ“ ì§€ì—­: ${region}`);
            console.log(`ğŸ·ï¸ íƒ€ì…: ${type}`);
            console.log(`ğŸ“Š ìš”ì²­ ê°œìˆ˜: ${numOfRows}`);
        }

        // API í‚¤ í™•ì¸
        const apiKey = getValidApiKey();
        if (!apiKey) {
            return res.status(500).json({
                success: false,
                message: 'API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                timestamp: new Date().toISOString()
            });
        }

        if (isDev) console.log('âœ… API í‚¤ í™•ì¸ë¨');

        let result = {};

        if (type === 'all') {
            // ì „ì²´ íƒ€ì… ë³‘ë ¬ ìˆ˜ì§‘
            if (isDev) console.log('ğŸŒ ì „ì²´ íƒ€ì… ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘...');
            result = await fetchAllTypesData(apiKey, region, numOfRows);
        } else {
            // ë‹¨ì¼ íƒ€ì… ìˆ˜ì§‘
            if (isDev) console.log(`ğŸ¯ ${type} ë°ì´í„° ìˆ˜ì§‘ ì‹œì‘...`);
            result[type] = await fetchTourismDataWithRetry(apiKey, region, type, numOfRows);
        }

        const responseTime = Date.now() - startTime;
        const totalCount = getTotalCount(result);

        return res.status(200).json({
            success: true,
            data: result,
            meta: {
                region: region,
                type: type,
                detailLevel: detail,
                totalCount: totalCount,
                responseTime: `${responseTime}ms`,
                timestamp: new Date().toISOString(),
                apiVersion: 'KorService2'
            },
            message: `âœ… ${region} ${type} í†µí•© ê´€ê´‘ ì •ë³´ ${totalCount}ê°œ ìˆ˜ì§‘ ì™„ë£Œ`
        });

    } catch (error) {
        console.error('âŒ í†µí•© ê´€ê´‘ API ì˜¤ë¥˜:', error);
        return res.status(500).json({
            success: false,
            error: error.message,
            message: 'í†µí•© ê´€ê´‘ ì •ë³´ ìˆ˜ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
            timestamp: new Date().toISOString()
        });
    }
}

// ì…ë ¥ íŒŒë¼ë¯¸í„° ê²€ì¦ ë° íŒŒì‹±
function validateAndParseParams(query) {
    const { 
        region = 'ì„œìš¸', 
        type = 'festivals', 
        detail = 'basic',
        numOfRows = '50' 
    } = query;

    // ì§€ì—­ ê²€ì¦
    if (!AREA_CODES[region]) {
        return {
            error: `ì§€ì›í•˜ì§€ ì•ŠëŠ” ì§€ì—­ì…ë‹ˆë‹¤: ${region}. ì§€ì› ì§€ì—­: ${Object.keys(AREA_CODES).join(', ')}`
        };
    }

    // íƒ€ì… ê²€ì¦
    if (type !== 'all' && !CONTENT_TYPES[type]) {
        return {
            error: `ì§€ì›í•˜ì§€ ì•ŠëŠ” íƒ€ì…ì…ë‹ˆë‹¤: ${type}. ì§€ì› íƒ€ì…: ${Object.keys(CONTENT_TYPES).filter(k => k !== 'all').join(', ')}, all`
        };
    }

    // ê°œìˆ˜ ê²€ì¦
    const parsedNumOfRows = parseInt(numOfRows);
    if (isNaN(parsedNumOfRows) || parsedNumOfRows < 1) {
        return {
            error: 'numOfRowsëŠ” 1 ì´ìƒì˜ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤'
        };
    }

    const validNumOfRows = Math.min(parsedNumOfRows, API_CONFIG.maxItemsPerRequest);

    return {
        region,
        type,
        detail,
        numOfRows: validNumOfRows
    };
}

// ìœ íš¨í•œ API í‚¤ ì°¾ê¸°
function getValidApiKey() {
    const possibleKeys = [
        process.env.TOURISM_API_KEY,
        process.env.TOUR_API_KEY,
        process.env.JEONBUK_API_KEY,
        process.env.WEATHER_API_KEY,
        process.env.REGIONAL_API_KEY
    ];

    return possibleKeys.find(key => key && key.length > 0);
}

// ì „ì²´ íƒ€ì… ë°ì´í„° ë³‘ë ¬ ìˆ˜ì§‘
async function fetchAllTypesData(apiKey, region, totalNumOfRows) {
    const types = ['festivals', 'accommodation', 'restaurants', 'culture', 'attractions'];
    const itemsPerType = Math.floor(totalNumOfRows / types.length);
    
    // ë³‘ë ¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì§€ì—° ì‹œê°„ì„ ê°€ì§„ Promise ë°°ì—´
    const promises = types.map((type, index) => 
        new Promise(resolve => 
            setTimeout(async () => {
                try {
                    const data = await fetchTourismDataWithRetry(apiKey, region, type, itemsPerType);
                    resolve({ type, data });
                } catch (error) {
                    if (isDev) console.error(`âŒ ${type} ìˆ˜ì§‘ ì‹¤íŒ¨:`, error);
                    resolve({ type, data: [] });
                }
            }, index * 300) // 300ms ê°„ê²©ìœ¼ë¡œ ìš”ì²­
        )
    );

    const results = await Promise.all(promises);
    
    // ê²°ê³¼ ì •ë¦¬
    const result = {};
    results.forEach(({ type, data }) => {
        result[type] = data;
    });

    return result;
}

// ì¬ì‹œë„ ë¡œì§ì´ í¬í•¨ëœ ê´€ê´‘ ë°ì´í„° ìˆ˜ì§‘
async function fetchTourismDataWithRetry(apiKey, region, type, numOfRows, retryCount = 0) {
    try {
        return await fetchTourismData(apiKey, region, type, numOfRows);
    } catch (error) {
        if (retryCount < API_CONFIG.maxRetries) {
            if (isDev) console.log(`ğŸ”„ ${type} ì¬ì‹œë„ ${retryCount + 1}/${API_CONFIG.maxRetries}`);
            await sleep(API_CONFIG.retryDelay * (retryCount + 1));
            return fetchTourismDataWithRetry(apiKey, region, type, numOfRows, retryCount + 1);
        }
        throw error;
    }
}

// ê´€ê´‘ ë°ì´í„° ìˆ˜ì§‘ (Service2 ë²„ì „)
async function fetchTourismData(apiKey, region, type, numOfRows) {
    const areaCode = AREA_CODES[region];
    const contentTypeId = CONTENT_TYPES[type];

    if (isDev) {
        console.log(`ğŸ” ${region} (${areaCode}) ${type} (${contentTypeId}) ìˆ˜ì§‘...`);
    }

    const params = new URLSearchParams({
        serviceKey: apiKey,
        numOfRows: numOfRows.toString(),
        pageNo: '1',
        MobileOS: 'ETC',
        MobileApp: 'HealingK',
        _type: 'json',
        contentTypeId: contentTypeId.toString(),
        areaCode: areaCode.toString(),
        arrange: 'D',
        listYN: 'Y',
        mapinfoYN: 'Y',
        imageYN: 'Y'
    });

    // AbortControllerë¥¼ ì‚¬ìš©í•œ timeout ì²˜ë¦¬
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), API_CONFIG.timeout);

    try {
        const response = await fetch(`${API_CONFIG.baseUrl}?${params.toString()}`, {
            signal: controller.signal,
            headers: {
                'User-Agent': 'HealingK/1.0',
                'Accept': 'application/json',
                'Cache-Control': 'no-cache'
            }
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const data = await response.json();
        
        if (data.response?.header?.resultCode === '0000') {
            const items = data.response.body?.items?.item || [];
            const itemsArray = Array.isArray(items) ? items : [items];
            
            if (isDev) {
                console.log(`âœ… ${type}: ${itemsArray.length}ê°œ ìˆ˜ì§‘ ì™„ë£Œ`);
            }
            
            return processDataInChunks(itemsArray, type, contentTypeId);
        } else {
            const errorMsg = data.response?.header?.resultMsg || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
            if (isDev) {
                console.log(`âš ï¸ ${type}: ë°ì´í„° ì—†ìŒ (${errorMsg})`);
            }
            return [];
        }

    } catch (error) {
        clearTimeout(timeoutId);
        
        if (error.name === 'AbortError') {
            throw new Error(`${type} ìš”ì²­ ì‹œê°„ ì´ˆê³¼ (${API_CONFIG.timeout}ms)`);
        }
        
        throw new Error(`${type} ìˆ˜ì§‘ ì‹¤íŒ¨: ${error.message}`);
    }
}

// ë°ì´í„°ë¥¼ ì²­í¬ ë‹¨ìœ„ë¡œ ì²˜ë¦¬ (ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±)
function processDataInChunks(itemsArray, type, contentTypeId) {
    const result = [];
    
    for (let i = 0; i < itemsArray.length; i += API_CONFIG.chunkSize) {
        const chunk = itemsArray.slice(i, i + API_CONFIG.chunkSize);
        const processedChunk = chunk.map(item => transformData(item, type, contentTypeId));
        result.push(...processedChunk);
    }
    
    return result;
}

// ë°ì´í„° ë³€í™˜ (ê°œì„ ëœ ë²„ì „)
function transformData(item, type, contentTypeId) {
    const baseData = {
        id: item.contentid || '',
        title: (item.title || 'ì œëª© ì—†ìŒ').trim(),
        location: (item.addr1 || 'ì£¼ì†Œ ì—†ìŒ').trim(),
        detailLocation: (item.addr2 || '').trim(),
        region: getRegionFromAddr(item.addr1),
        tel: (item.tel || '').trim(),
        contentTypeId: parseInt(contentTypeId),
        contentType: type,
        coordinates: {
            x: parseFloat(item.mapx) || null,
            y: parseFloat(item.mapy) || null
        },
        images: {
            main: item.firstimage || null,
            thumbnail: item.firstimage2 || null
        },
        timestamps: {
            created: item.createdtime || '',
            modified: item.modifiedtime || ''
        },
        mlevel: item.mlevel || '1',
        zipcode: item.zipcode || '',
        bookmark: false,
        rating: Math.floor(Math.random() * 3) + 3, // 3-5 ëœë¤ í‰ì 
        originalData: {
            source: 'korean_tourism_organization_service2',
            contentType: type,
            isRealData: true,
            lastUpdated: new Date().toISOString()
        }
    };

    // íƒ€ì…ë³„ íŠ¹í™” ë°ì´í„°
    switch (parseInt(contentTypeId)) {
        case 15: // ì¶•ì œ
            return {
                ...baseData,
                category: 'festivals',
                eventStartDate: item.eventstartdate || '',
                eventEndDate: item.eventenddate || '',
                status: calculateEventStatus(item.eventstartdate, item.eventenddate),
                daysLeft: calculateDaysLeft(item.eventstartdate, item.eventenddate),
                eventDescription: item.overview || '',
                sponsor: item.sponsor1 || '',
                eventPlace: item.eventplace || ''
            };

        case 32: // ìˆ™ë°•
            return {
                ...baseData,
                category: 'accommodation',
                accommodationType: getAccommodationType(item.title),
                features: {
                    benikia: item.benikia === 'Y',
                    goodstay: item.goodstay === 'Y',
                    hanok: item.hanok === 'Y'
                },
                roomCount: parseInt(item.roomcount) || null,
                roomType: item.roomtype || '',
                checkInTime: item.checkintime || '',
                checkOutTime: item.checkouttime || ''
            };

        case 39: // ìŒì‹ì 
            return {
                ...baseData,
                category: 'restaurants',
                foodType: getFoodType(item.title),
                specialMenu: (item.treatmenu || '').trim(),
                facilities: {
                    smoking: item.smoking || '',
                    packing: item.packing || '',
                    parking: item.parking || ''
                },
                openTime: item.opentime || '',
                restDate: item.restdatefood || ''
            };

        case 14: // ë¬¸í™”ì‹œì„¤
            return {
                ...baseData,
                category: 'culture',
                facilityType: 'culture',
                scale: item.scale || '',
                capacity: parseInt(item.accomcount) || null,
                useTime: item.usetimeculture || '',
                restDate: item.restdateculture || '',
                useFee: item.usefee || ''
            };

        case 12: // ê´€ê´‘ì§€
            return {
                ...baseData,
                category: 'attractions',
                attractionType: 'tourism',
                heritage: {
                    level1: item.heritage1 || '',
                    level2: item.heritage2 || '',
                    level3: item.heritage3 || ''
                },
                useTime: item.usetime || '',
                restDate: item.restdate || '',
                ageLimit: item.agelimit || '',
                experienceAgeRange: item.expagerange || ''
            };

        default:
            return {
                ...baseData,
                category: 'etc'
            };
    }
}

// ê°œì„ ëœ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤

function getAccommodationType(title) {
    const titleLower = title.toLowerCase();
    
    if (titleLower.includes('í˜¸í…”') || titleLower.includes('hotel')) return 'hotel';
    if (titleLower.includes('íœì…˜') || titleLower.includes('pension')) return 'pension';
    if (titleLower.includes('ëª¨í…”') || titleLower.includes('motel')) return 'motel';
    if (titleLower.includes('ë¦¬ì¡°íŠ¸') || titleLower.includes('resort')) return 'resort';
    if (titleLower.includes('í•œì˜¥') || titleLower.includes('hanok')) return 'hanok';
    if (titleLower.includes('ê²ŒìŠ¤íŠ¸í•˜ìš°ìŠ¤') || titleLower.includes('guesthouse')) return 'guesthouse';
    if (titleLower.includes('ìº í•‘') || titleLower.includes('camping')) return 'camping';
    
    return 'etc';
}

function getFoodType(title) {
    const titleLower = title.toLowerCase();
    
    if (titleLower.includes('í•œì‹') || titleLower.includes('korean')) return 'korean';
    if (titleLower.includes('ì¤‘ì‹') || titleLower.includes('chinese')) return 'chinese';
    if (titleLower.includes('ì¼ì‹') || titleLower.includes('japanese')) return 'japanese';
    if (titleLower.includes('ì–‘ì‹') || titleLower.includes('western')) return 'western';
    if (titleLower.includes('ì¹´í˜') || titleLower.includes('cafe')) return 'cafe';
    if (titleLower.includes('ì¹˜í‚¨') || titleLower.includes('chicken')) return 'chicken';
    if (titleLower.includes('í”¼ì') || titleLower.includes('pizza')) return 'pizza';
    if (titleLower.includes('ë¶„ì‹') || titleLower.includes('snack')) return 'snack';
    if (titleLower.includes('í•´ì‚°ë¬¼') || titleLower.includes('seafood')) return 'seafood';
    if (titleLower.includes('ê³ ê¸°') || titleLower.includes('meat')) return 'meat';
    
    return 'etc';
}

function parseKoreanDate(dateStr) {
    if (!dateStr || dateStr.length !== 8) return null;
    
    try {
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(4, 6);
        const day = dateStr.substring(6, 8);
        
        // í•œêµ­ ì‹œê°„ëŒ€ ê³ ë ¤
        return new Date(`${year}-${month}-${day}T00:00:00+09:00`);
    } catch (error) {
        return null;
    }
}

function calculateEventStatus(startDate, endDate) {
    if (!startDate || !endDate) return 'unknown';
    
    const start = parseKoreanDate(startDate);
    const end = parseKoreanDate(endDate);
    
    if (!start || !end) return 'unknown';
    
    const now = new Date();
    const nowKST = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9
    
    if (nowKST < start) return 'upcoming';
    if (nowKST > end) return 'ended';
    return 'ongoing';
}

function calculateDaysLeft(startDate, endDate) {
    if (!startDate || !endDate) return 'ë‚ ì§œ ë¯¸ì •';
    
    const start = parseKoreanDate(startDate);
    const end = parseKoreanDate(endDate);
    
    if (!start || !end) return 'ë‚ ì§œ ë¯¸ì •';
    
    const now = new Date();
    const nowKST = new Date(now.getTime() + (9 * 60 * 60 * 1000)); // UTC+9
    
    if (nowKST < start) {
        const diff = Math.ceil((start - nowKST) / (1000 * 60 * 60 * 24));
        return `${diff}ì¼ í›„ ì‹œì‘`;
    }
    
    if (nowKST > end) {
        return 'ì¢…ë£Œë¨';
    }
    
    const diff = Math.ceil((end - nowKST) / (1000 * 60 * 60 * 24));
    return `${diff}ì¼ ë‚¨ìŒ`;
}

function getTotalCount(result) {
    let total = 0;
    for (const key in result) {
        if (Array.isArray(result[key])) {
            total += result[key].length;
        }
    }
    return total;
}

function getRegionFromAddr(addr) {
    if (!addr) return 'ê¸°íƒ€';
    
    const regions = Object.keys(AREA_CODES);
    for (const region of regions) {
        if (addr.includes(region)) {
            return region;
        }
    }
    
    // ê´‘ì—­ì‹œ/ë„ ë‹¨ìœ„ë¡œë„ í™•ì¸
    const provinces = ['ê²½ê¸°', 'ê°•ì›', 'ì¶©ë¶', 'ì¶©ë‚¨', 'ì „ë¶', 'ì „ë‚¨', 'ê²½ë¶', 'ê²½ë‚¨', 'ì œì£¼'];
    for (const province of provinces) {
        if (addr.includes(province)) {
            return province;
        }
    }
    
    return 'ê¸°íƒ€';
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
