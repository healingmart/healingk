/**
 * 한국관광공사 TOURAPI(OpenAPI) 통합 서버리스 API
 * 
 * 이 API는 한국관광공사의 다양한 관광 데이터를 통합적으로 제공합니다.
 * 카테고리별 엔드포인트 맵핑을 통해 축제, 관광지, 숙박, 음식점, 문화시설 정보를 표준화된 형식으로 제공합니다.
 * CSRF 토큰 발급 및 검증 기능을 포함하여 블로그 임베딩 시 보안을 강화합니다.
 * 
 * @author HealingK
 * @version 1.0.0
 * @license MIT
 */

// ===== 상수 및 설정 =====
const TOUR_API_BASE_URL = 'https://apis.data.go.kr/B551011/KorService2';
const COMMON_PARAMS = {
  MobileOS: 'ETC',
  MobileApp: 'HealingK',
  _type: 'json'
};

// 카테고리별 엔드포인트 맵핑
const CATEGORY_ENDPOINTS = {
  festival: 'searchFestival',
  tourspot: 'areaBasedList',
  stay: 'searchStay',
  food: 'searchFood',
  culture: 'searchCultural'
};

// 지역 코드 맵핑
const AREA_CODES = {
  // 특별시/광역시
  '서울': 1, '부산': 6, '대구': 4, '인천': 2, '광주': 5, '대전': 3, '울산': 7,
  '세종': 8, '세종시': 8,
  
  // 도 지역
  '경기': 31, '강원': 32, '충북': 33, '충남': 34, '전북': 37, '전남': 38, 
  '경북': 35, '경남': 36, '제주': 39,
  
  // 주요 관광 도시
  '강릉': 32, '춘천': 32, '속초': 32, '평창': 32,
  '천안': 34, '공주': 34, '부여': 34,
  '전주': 37, '군산': 37, '정읍': 37, '남원': 37,
  '목포': 38, '순천': 38, '여수': 38,
  '경주': 35, '안동': 35, '포항': 35,
  '통영': 36, '거제': 36, '남해': 36,
  '제주시': 39, '서귀포': 39,
  
  // 경기도 주요 도시
  '수원': 31, '성남': 31, '안양': 31, '부천': 31, '광명': 31, '평택': 31,
  '동탄': 31, '일산': 31, '분당': 31, '판교': 31
};

// CSRF 토큰 저장소 (실제 환경에서는 Redis 등의 외부 저장소 사용 권장)
const csrfTokens = new Map();

// ===== 유틸리티 함수 =====

/**
 * CSRF 토큰 생성 함수
 * @returns {string} 생성된 CSRF 토큰
 */
function generateCSRFToken() {
  const timestamp = Date.now().toString();
  const random = Math.random().toString(36).substring(2, 15);
  const token = `${timestamp}-${random}`;
  
  // 토큰 저장 (유효시간 30분)
  csrfTokens.set(token, {
    createdAt: Date.now(),
    expiresAt: Date.now() + 30 * 60 * 1000 // 30분
  });
  
  // 만료된 토큰 정리 (가비지 컬렉션)
  cleanupExpiredTokens();
  
  return token;
}

/**
 * CSRF 토큰 검증 함수
 * @param {string} token 검증할 CSRF 토큰
 * @returns {boolean} 토큰 유효성 여부
 */
function validateCSRFToken(token) {
  if (!token || !csrfTokens.has(token)) {
    return false;
  }
  
  const tokenData = csrfTokens.get(token);
  const now = Date.now();
  
  // 토큰 만료 확인
  if (now > tokenData.expiresAt) {
    csrfTokens.delete(token);
    return false;
  }
  
  return true;
}

/**
 * 만료된 CSRF 토큰 정리 함수
 */
function cleanupExpiredTokens() {
  const now = Date.now();
  for (const [token, data] of csrfTokens.entries()) {
    if (now > data.expiresAt) {
      csrfTokens.delete(token);
    }
  }
}

/**
 * API 키 가져오기 함수
 * @returns {string|null} API 키 또는 null
 */
function getAPIKey() {
  return process.env.TOUR_API_KEY || 
         process.env.TOURISM_API_KEY || 
         process.env.KOREA_TOURISM_API_KEY || 
         null;
}

/**
 * 응답 데이터를 표준 포맷으로 변환하는 함수
 * @param {string} category 카테고리
 * @param {Array|Object} items API 응답 아이템
 * @param {number} totalCount 총 아이템 수
 * @returns {Object} 표준화된 응답 객체
 */
function standardizeResponse(category, items, totalCount) {
  const timestamp = new Date().toISOString();
  const standardItems = Array.isArray(items) ? items : [items];
  
  return {
    meta: {
      category,
      totalCount: totalCount || standardItems.length,
      timestamp
    },
    items: standardItems.map(item => {
      // 기본 필드 매핑
      const standardItem = {
        id: item.contentid || item.contentId || item.id || '',
        title: item.title || item.name || '',
        addr: item.addr1 || item.address || item.addr || '',
        image: item.firstimage || item.firstImage || item.image || '',
        tel: item.tel || item.telephone || '',
        homepage: item.homepage || item.homePage || item.url || ''
      };
      
      // 카테고리별 추가 필드 매핑
      if (category === 'festival') {
        standardItem.startDate = item.eventstartdate || item.eventStartDate || '';
        standardItem.endDate = item.eventenddate || item.eventEndDate || '';
      }
      
      // 위치 정보 매핑
      if (item.mapx && item.mapy) {
        standardItem.map = {
          lng: parseFloat(item.mapx),
          lat: parseFloat(item.mapy)
        };
      } else if (item.mapX && item.mapY) {
        standardItem.map = {
          lng: parseFloat(item.mapX),
          lat: parseFloat(item.mapY)
        };
      } else if (item.longitude && item.latitude) {
        standardItem.map = {
          lng: parseFloat(item.longitude),
          lat: parseFloat(item.latitude)
        };
      }
      
      return standardItem;
    })
  };
}

/**
 * API 호출 함수
 * @param {string} endpoint API 엔드포인트
 * @param {Object} params API 호출 파라미터
 * @returns {Promise<Object>} API 응답 객체
 */
async function callTourAPI(endpoint, params) {
  try {
    const apiKey = getAPIKey();
    if (!apiKey) {
      throw new Error('API 키가 설정되지 않았습니다.');
    }
    
    // 파라미터 구성
    const queryParams = new URLSearchParams({
      serviceKey: apiKey,
      ...COMMON_PARAMS,
      ...params
    });
    
    // API 호출
    const url = `${TOUR_API_BASE_URL}/${endpoint}?${queryParams.toString()}`;
    console.log(`API 호출: ${url}`);
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'HealingK-Tourism/1.0'
      },
      timeout: 10000 // 10초 타임아웃
    });
    
    if (!response.ok) {
      throw new Error(`API 호출 실패: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // 응답 코드 확인
    const header = data.response?.header;
    if (header && header.resultCode !== '0000') {
      throw new Error(`API 오류: ${header.resultCode} ${header.resultMsg}`);
    }
    
    // 데이터 추출
    const items = data.response?.body?.items?.item || [];
    const totalCount = data.response?.body?.totalCount || items.length;
    
    return { items, totalCount };
    
  } catch (error) {
    console.error('API 호출 오류:', error);
    throw error;
  }
}

/**
 * 블로그 임베딩용 HTML 생성 함수
 * @param {string} category 카테고리
 * @param {Object} data 데이터 객체
 * @param {string} csrfToken CSRF 토큰
 * @returns {string} HTML 문자열
 */
function generateEmbedHTML(category, data, csrfToken) {
  const items = data.items || [];
  
  let html = `
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>HealingK 관광 정보</title>
      <style>
        * {
          box-sizing: border-box;
          font-family: 'Noto Sans KR', sans-serif;
        }
        body {
          margin: 0;
          padding: 0;
          background-color: #f8f9fa;
        }
        .container {
          max-width: 100%;
          padding: 10px;
        }
        .header {
          background-color: #007bff;
          color: white;
          padding: 10px;
          border-radius: 5px 5px 0 0;
          font-weight: bold;
        }
        .item {
          background-color: white;
          margin-bottom: 10px;
          border-radius: 5px;
          box-shadow: 0 2px 5px rgba(0,0,0,0.1);
          overflow: hidden;
        }
        .item-content {
          padding: 10px;
        }
        .item-image {
          width: 100%;
          height: 150px;
          object-fit: cover;
        }
        .item-title {
          font-weight: bold;
          margin: 5px 0;
        }
        .item-addr {
          color: #666;
          font-size: 0.9em;
          margin-bottom: 5px;
        }
        .item-date {
          color: #007bff;
          font-size: 0.8em;
        }
        .footer {
          text-align: center;
          font-size: 0.8em;
          color: #666;
          margin-top: 10px;
        }
        .csrf-token {
          display: none;
        }
      </style>
    </head>
    <body>
      <div class="container">
        <div class="header">
          HealingK ${getCategoryName(category)} 정보
        </div>
        <div class="csrf-token" data-token="${csrfToken}"></div>
  `;
  
  // 아이템 목록 생성
  items.forEach(item => {
    html += `
      <div class="item">
        ${item.image ? `<img src="${item.image}" alt="${item.title}" class="item-image">` : ''}
        <div class="item-content">
          <div class="item-title">${item.title}</div>
          <div class="item-addr">${item.addr}</div>
          ${category === 'festival' && item.startDate ? 
            `<div class="item-date">${formatDate(item.startDate)} ~ ${formatDate(item.endDate)}</div>` : ''}
        </div>
      </div>
    `;
  });
  
  html += `
        <div class="footer">
          제공: 한국관광공사 TOURAPI | HealingK
        </div>
      </div>
      <script>
        // CSRF 토큰 자동 갱신 및 데이터 업데이트 스크립트
        (function() {
          const csrfToken = document.querySelector('.csrf-token').dataset.token;
          
          // 데이터 갱신 함수
          async function refreshData() {
            try {
              const response = await fetch('/api/all_tourism?category=${category}&csrfToken=${csrfToken}', {
                headers: {
                  'X-CSRF-Token': csrfToken
                }
              });
              
              if (response.ok) {
                const data = await response.json();
                // 필요시 데이터 갱신 로직 구현
              }
            } catch (error) {
              console.error('데이터 갱신 오류:', error);
            }
          }
          
          // 30분마다 데이터 갱신
          setInterval(refreshData, 30 * 60 * 1000);
        })();
      </script>
    </body>
    </html>
  `;
  
  return html;
}

/**
 * 카테고리 이름 변환 함수
 * @param {string} category 카테고리 코드
 * @returns {string} 카테고리 한글명
 */
function getCategoryName(category) {
  const categoryNames = {
    festival: '축제',
    tourspot: '관광지',
    stay: '숙박',
    food: '음식점',
    culture: '문화시설'
  };
  
  return categoryNames[category] || '관광';
}

/**
 * 날짜 포맷 함수
 * @param {string} dateStr YYYYMMDD 형식의 날짜 문자열
 * @returns {string} YYYY-MM-DD 형식의 날짜 문자열
 */
function formatDate(dateStr) {
  if (!dateStr || dateStr.length !== 8) return dateStr;
  
  const year = dateStr.substring(0, 4);
  const month = dateStr.substring(4, 6);
  const day = dateStr.substring(6, 8);
  
  return `${year}-${month}-${day}`;
}

// ===== 메인 핸들러 =====
module.exports = async function handler(req, res) {
  // CORS 설정
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization, X-CSRF-Token');

  // OPTIONS 요청 처리
  if (req.method === 'OPTIONS') {
    return res.status(200).end();
  }
  
  // 실행 시간 측정 시작
  const startTime = Date.now();
  
  try {
    // CSRF 토큰 발급 요청 처리
    if (req.query.getToken === 'true') {
      const token = generateCSRFToken();
      return res.status(200).json({
        success: true,
        csrfToken: token,
        expiresIn: 30 * 60, // 30분 (초 단위)
        timestamp: new Date().toISOString()
      });
    }
    
    // 쿼리 파라미터 추출
    const {
      category,
      areaCode,
      sigunguCode,
      eventStartDate,
      eventEndDate,
      keyword,
      pageNo = '1',
      numOfRows = '10',
      csrfToken,
      format
    } = req.query;
    
    // CSRF 토큰 검증 (블로그 임베딩 시)
    const headerToken = req.headers['x-csrf-token'];
    if (headerToken && !validateCSRFToken(headerToken)) {
      return res.status(403).json({
        success: false,
        error: 'CSRF 토큰이 유효하지 않습니다.',
        timestamp: new Date().toISOString()
      });
    }
    
    // 카테고리 필수 확인
    if (!category || !CATEGORY_ENDPOINTS[category]) {
      return res.status(400).json({
        success: false,
        error: '유효한 카테고리를 지정해주세요. (festival, tourspot, stay, food, culture)',
        timestamp: new Date().toISOString()
      });
    }
    
    // 엔드포인트 결정
    const endpoint = CATEGORY_ENDPOINTS[category];
    
    // API 호출 파라미터 구성
    const apiParams = {
      numOfRows,
      pageNo
    };
    
    // 지역 코드 처리
    if (areaCode) {
      apiParams.areaCode = areaCode;
    }
    
    // 시군구 코드 처리
    if (sigunguCode) {
      apiParams.sigunguCode = sigunguCode;
    }
    
    // 축제 날짜 처리 (축제 카테고리인 경우)
    if (category === 'festival') {
      if (eventStartDate) {
        apiParams.eventStartDate = eventStartDate;
      }
      if (eventEndDate) {
        apiParams.eventEndDate = eventEndDate;
      }
    }
    
    // 키워드 검색 처리
    if (keyword) {
      apiParams.keyword = keyword;
    }
    
    // API 호출
    const apiResult = await callTourAPI(endpoint, apiParams);
    
    // 응답 데이터 표준화
    const standardizedData = standardizeResponse(
      category, 
      apiResult.items, 
      apiResult.totalCount
    );
    
    // 응답 형식에 따른 처리
    if (format === 'html') {
      // HTML 형식 응답 (블로그 임베딩용)
      const token = csrfToken || generateCSRFToken();
      const html = generateEmbedHTML(category, standardizedData, token);
      
      res.setHeader('Content-Type', 'text/html; charset=utf-8');
      return res.status(200).send(html);
    } else {
      // JSON 형식 응답 (기본)
      return res.status(200).json({
        success: true,
        ...standardizedData,
        responseTime: Date.now() - startTime,
        timestamp: new Date().toISOString()
      });
    }
    
  } catch (error) {
    console.error('API 처리 오류:', error);
    
    return res.status(500).json({
      success: false,
      error: error.message || 'Internal Server Error',
      timestamp: new Date().toISOString()
    });
  }
};
