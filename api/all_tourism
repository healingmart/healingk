// api/all_tourism.js

const AREA_CODES = {
    'ì„œìš¸': 1, 'ë¶€ì‚°': 6, 'ì œì£¼': 39, 'ê°•ë¦‰': 32,
    'ì „ì£¼': 37, 'ëŒ€êµ¬': 4, 'ê´‘ì£¼': 5, 'ëŒ€ì „': 3,
    'ì¸ì²œ': 2, 'ìš¸ì‚°': 7, 'ê²½ì£¼': 35, 'ì¶˜ì²œ': 32
};

const CONTENT_TYPES = {
    festivals: 15,      // ì¶•ì œê³µì—°í–‰ì‚¬
    attractions: 12,    // ê´€ê´‘ì§€
    accommodation: 32,  // ìˆ™ë°•
    restaurants: 39,    // ìŒì‹ì 
    culture: 14,        // ë¬¸í™”ì‹œì„¤
    activities: 28,     // ë ˆí¬ì¸ 
    shopping: 38,       // ì‡¼í•‘
    all: 'all'
};

const ACCOMMODATION_TYPES = {
    'ê´€ê´‘í˜¸í…”': 'hotel', 'íœì…˜': 'pension', 'ëª¨í…”': 'motel',
    'ê²ŒìŠ¤íŠ¸í•˜ìš°ìŠ¤': 'guesthouse', 'ë¦¬ì¡°íŠ¸': 'resort', 'ì½˜ë„': 'condo', 'í•œì˜¥': 'hanok'
};

const RESTAURANT_TYPES = {
    'í•œì‹': 'korean', 'ì¤‘ì‹': 'chinese', 'ì¼ì‹': 'japanese', 
    'ì–‘ì‹': 'western', 'ì¹´í˜': 'cafe', 'ë² ì´ì»¤ë¦¬': 'bakery'
};

export default async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    try {
        const startTime = Date.now();
        const { 
            region = 'ì„œìš¸', 
            type = 'festivals', 
            detail = 'basic',
            ranking = 'true',
            numOfRows = 100,
            crossRecommend = 'false',
            radius = '5000'
        } = req.query;

        console.log('ğŸš€ === í†µí•© ê´€ê´‘ API ì‹œì‘ ===');
        console.log(`ğŸ“ ì§€ì—­: ${region}`);
        console.log(`ğŸ·ï¸ íƒ€ì…: ${type}`);
        console.log(`ğŸ“Š ìƒì„¸ë„: ${detail}`);
        console.log(`ğŸ† ë­í‚¹: ${ranking}`);
        console.log(`ğŸ”— ì—°ê´€ì¶”ì²œ: ${crossRecommend}`);

        // API í‚¤ í™•ì¸
        const possibleKeys = [
            process.env.JEONBUK_API_KEY,
            process.env.TOURISM_API_KEY,
            process.env.TOUR_API_KEY,
            process.env.WEATHER_API_KEY,
            process.env.REGIONAL_API_KEY
        ];

        const apiKey = possibleKeys.find(key => key);
        
        if (!apiKey) {
            console.log('âŒ API í‚¤ ì—†ìŒ');
            return res.status(200).json({
                success: false,
                message: 'API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤',
                data: {},
                responseTime: `${Date.now() - startTime}ms`
            });
        }

        console.log('âœ… API í‚¤ í™•ì¸:', `${apiKey.substring(0, 10)}...`);

        let result = {};

        // ì „ì²´ íƒ€ì… ìš”ì²­
        if (type === 'all') {
            console.log('ğŸŒ ì „ì²´ íƒ€ì… ë°ì´í„° ìˆ˜ì§‘...');
            result = await collectAllTypesData(apiKey, region, detail, ranking, parseInt(numOfRows));
        } else {
            // ë‹¨ì¼ íƒ€ì… ìš”ì²­
            console.log(`ğŸ¯ ${type} ë‹¨ì¼ íƒ€ì… ë°ì´í„° ìˆ˜ì§‘...`);
            const singleTypeData = await collectTourismData(apiKey, region, type, parseInt(numOfRows));
            
            if (!singleTypeData.success) {
                throw new Error(singleTypeData.error || 'ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨');
            }

            let processedData = singleTypeData.data;

            // ìƒì„¸ì •ë³´ ìˆ˜ì§‘
            if (detail === 'full' && processedData.length > 0) {
                console.log('ğŸ“‹ ìƒì„¸ì •ë³´ ìˆ˜ì§‘ ì‹œì‘...');
                processedData = await enrichWithDetailInfo(apiKey, processedData, type);
            }

            // ë­í‚¹ ê³„ì‚°
            if (ranking === 'true' && processedData.length > 0) {
                console.log('ğŸ† ë­í‚¹ ê³„ì‚° ì‹œì‘...');
                processedData = calculateRankings(processedData, type);
            }

            result[type] = processedData;
        }

        // ì—°ê´€ ì¶”ì²œ ì‹œìŠ¤í…œ
        if (crossRecommend === 'true' && type !== 'all') {
            console.log('ğŸ”— ì—°ê´€ ì¶”ì²œ ì‹œìŠ¤í…œ ì‹œì‘...');
            result.recommendations = await getCrossRecommendations(
                apiKey, region, type, result[type], parseInt(radius)
            );
        }

        const responseTime = Date.now() - startTime;

        return res.status(200).json({
            success: true,
            data: result,
            meta: {
                region: region,
                type: type,
                detailLevel: detail,
                hasRanking: ranking === 'true',
                hasCrossRecommend: crossRecommend === 'true',
                totalCount: getTotalCount(result),
                responseTime: `${responseTime}ms`,
                timestamp: new Date().toISOString(),
                apiVersion: '2.0',
                features: ['multiType', 'detailInfo', 'ranking', 'crossRecommend']
            },
            message: `âœ… ${region} ${type} í†µí•© ê´€ê´‘ ì •ë³´ ${getTotalCount(result)}ê°œ ìˆ˜ì§‘ ì™„ë£Œ`
        });

    } catch (error) {
        console.error('âŒ í†µí•© ê´€ê´‘ API ì˜¤ë¥˜:', error);
        return res.status(500).json({
            success: false,
            error: error.message,
            message: 'í†µí•© ê´€ê´‘ ì •ë³´ ìˆ˜ì§‘ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤',
            timestamp: new Date().toISOString()
        });
    }
}

// === ì „ì²´ íƒ€ì… ë°ì´í„° ìˆ˜ì§‘ ===
async function collectAllTypesData(apiKey, region, detail, ranking, numOfRows) {
    const types = ['festivals', 'attractions', 'accommodation', 'restaurants', 'culture'];
    const result = {};
    const itemsPerType = Math.floor(numOfRows / types.length);
    
    for (const type of types) {
        try {
            console.log(`ğŸ”„ ${type} ë°ì´í„° ìˆ˜ì§‘ ì¤‘...`);
            
            const typeData = await collectTourismData(apiKey, region, type, itemsPerType);
            
            if (typeData.success && typeData.data.length > 0) {
                let processedData = typeData.data;
                
                // ìƒì„¸ì •ë³´ ìˆ˜ì§‘
                if (detail === 'full') {
                    console.log(`ğŸ“‹ ${type} ìƒì„¸ì •ë³´ ìˆ˜ì§‘...`);
                    processedData = await enrichWithDetailInfo(apiKey, processedData, type);
                }
                
                // ë­í‚¹ ê³„ì‚°
                if (ranking === 'true') {
                    console.log(`ğŸ† ${type} ë­í‚¹ ê³„ì‚°...`);
                    processedData = calculateRankings(processedData, type);
                }
                
                result[type] = processedData;
                console.log(`âœ… ${type}: ${processedData.length}ê°œ ìˆ˜ì§‘ ì™„ë£Œ`);
            } else {
                result[type] = [];
                console.log(`âš ï¸ ${type}: ë°ì´í„° ì—†ìŒ`);
            }
            
            // íƒ€ì… ê°„ ë”œë ˆì´
            await sleep(400);
            
        } catch (error) {
            console.error(`âŒ ${type} ìˆ˜ì§‘ ì˜¤ë¥˜:`, error);
            result[type] = [];
        }
    }
    
    return result;
}

// === ê´€ê´‘ ë°ì´í„° ìˆ˜ì§‘ ===
async function collectTourismData(apiKey, region, type, numOfRows) {
    try {
        const areaCode = AREA_CODES[region] || 1;
        const contentTypeId = CONTENT_TYPES[type];

        if (!contentTypeId || contentTypeId === 'all') {
            throw new Error('ì˜¬ë°”ë¥´ì§€ ì•Šì€ íƒ€ì…');
        }

        console.log(`ğŸ” ${region} (${areaCode}) ${type} (${contentTypeId}) ë°ì´í„° ìˆ˜ì§‘...`);

        const allData = [];
        const maxPages = Math.ceil(numOfRows / 100);

        for (let page = 1; page <= Math.min(maxPages, 5); page++) {
            console.log(`ğŸ“„ ${type} í˜ì´ì§€ ${page} ìˆ˜ì§‘ ì¤‘...`);
            
            const pageData = await fetchTourismPage(apiKey, {
                areaCode,
                contentTypeId,
                numOfRows: Math.min(100, numOfRows - allData.length),
                pageNo: page
            });

            if (pageData.success && pageData.data.length > 0) {
                allData.push(...pageData.data);
                console.log(`âœ… ${type} í˜ì´ì§€ ${page}: ${pageData.data.length}ê°œ ìˆ˜ì§‘ (ì´ ${allData.length}ê°œ)`);
                
                if (pageData.data.length < 100 || allData.length >= numOfRows) {
                    break;
                }
            } else {
                console.log(`âŒ ${type} í˜ì´ì§€ ${page} ìˆ˜ì§‘ ì‹¤íŒ¨`);
                break;
            }

            await sleep(300);
        }

        console.log(`ğŸ¯ ${type} ì´ ${allData.length}ê°œ ë°ì´í„° ìˆ˜ì§‘ ì™„ë£Œ`);

        return {
            success: true,
            data: allData.slice(0, numOfRows)
        };

    } catch (error) {
        console.error(`âŒ ${type} ë°ì´í„° ìˆ˜ì§‘ ì˜¤ë¥˜:`, error);
        return {
            success: false,
            error: error.message
        };
    }
}

// === ê°œë³„ í˜ì´ì§€ ë°ì´í„° ìˆ˜ì§‘ ===
async function fetchTourismPage(apiKey, params) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/areaBasedList2';
        const queryParams = new URLSearchParams({
            serviceKey: apiKey,
            numOfRows: params.numOfRows,
            pageNo: params.pageNo,
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json',
            contentTypeId: params.contentTypeId,
            areaCode: params.areaCode,
            arrange: 'D'
        });

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 12000);

        const response = await fetch(`${url}?${queryParams.toString()}`, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'HealingK-Tourism/2.0'
            },
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        
        if (data.response?.header?.resultCode === '0000') {
            const items = data.response.body?.items?.item || [];
            const itemsArray = Array.isArray(items) ? items : [items];
            
            return {
                success: true,
                data: itemsArray.map(item => transformTourismData(item, params.contentTypeId))
            };
        } else {
            throw new Error(data.response?.header?.resultMsg || 'ë°ì´í„° ì—†ìŒ');
        }

    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// === ê´€ê´‘ ë°ì´í„° ë³€í™˜ (íƒ€ì…ë³„ íŠ¹í™”) ===
function transformTourismData(item, contentTypeId) {
    const baseData = {
        id: item.contentid,
        title: item.title || 'ì œëª© ì—†ìŒ',
        location: item.addr1 || 'ì£¼ì†Œ ì—†ìŒ',
        region: getRegionFromAddr(item.addr1),
        tel: item.tel || '',
        contentTypeId: contentTypeId,
        contentType: getContentTypeName(contentTypeId),
        mapx: item.mapx,
        mapy: item.mapy,
        image: item.firstimage || null,
        thumbnail: item.firstimage2 || null,
        createdtime: item.createdtime,
        modifiedtime: item.modifiedtime,
        mlevel: item.mlevel || '1',
        areacode: item.areacode,
        sigungucode: item.sigungucode,
        zipcode: item.zipcode || '',
        originalData: {
            source: 'korean_tourism_organization',
            contentType: getContentTypeName(contentTypeId),
            isRealData: true,
            apiVersion: '2.0'
        }
    };

    // íƒ€ì…ë³„ íŠ¹í™” ë°ì´í„° ì¶”ê°€
    switch (contentTypeId) {
        case '15': // ì¶•ì œ
            return {
                ...baseData,
                category: 'festivals',
                eventStartDate: item.eventstartdate || '',
                eventEndDate: item.eventenddate || '',
                status: calculateEventStatus(item.eventstartdate, item.eventenddate),
                daysLeft: calculateDaysLeft(item.eventstartdate, item.eventenddate),
                isWeekend: checkIfWeekend(item.eventstartdate, item.eventenddate)
            };

        case '32': // ìˆ™ë°•
            return {
                ...baseData,
                category: 'accommodation',
                accommodationType: getAccommodationType(item.title),
                benikia: item.benikia || 'N',
                goodstay: item.goodstay || 'N',
                hanok: item.hanok || 'N',
                businessHours: item.businessHours || ''
            };

        case '39': // ìŒì‹ì 
            return {
                ...baseData,
                category: 'restaurants',
                foodType: getFoodType(item.title, item.addr1),
                treatmenu: item.treatmenu || '',
                smoking: item.smoking || '',
                packing: item.packing || '',
                price: item.price || ''
            };

        case '14': // ë¬¸í™”ì‹œì„¤
            return {
                ...baseData,
                category: 'culture',
                facilityType: 'culture',
                scale: item.scale || '',
                accomcount: item.accomcount || '',
                usetime: item.usetime || ''
            };

        case '28': // ë ˆí¬ì¸ 
            return {
                ...baseData,
                category: 'activities',
                activityType: 'sports',
                openperiod: item.openperiod || '',
                usetimeleisure: item.usetimeleisure || '',
                age: item.age || ''
            };

        case '12': // ê´€ê´‘ì§€
            return {
                ...baseData,
                category: 'attractions',
                attractionType: 'tourism',
                heritage1: item.heritage1 || '',
                heritage2: item.heritage2 || '',
                heritage3: item.heritage3 || ''
            };

        default:
            return {
                ...baseData,
                category: getContentTypeName(contentTypeId)
            };
    }
}

// === ìƒì„¸ì •ë³´ ìˆ˜ì§‘ (íƒ€ì…ë³„ íŠ¹í™”) ===
async function enrichWithDetailInfo(apiKey, dataArray, type) {
    console.log(`ğŸ“‹ ${type} ${dataArray.length}ê°œ í•­ëª©ì˜ ìƒì„¸ì •ë³´ ìˆ˜ì§‘...`);
    
    const enrichedData = [];
    
    // ë°°ì¹˜ ì²˜ë¦¬ (3ê°œì”© - ì•ˆì „í•˜ê²Œ)
    for (let i = 0; i < dataArray.length; i += 3) {
        const batch = dataArray.slice(i, i + 3);
        
        const batchPromises = batch.map(item => 
            getTypeSpecificDetailInfo(apiKey, item, type)
                .then(detail => ({ ...item, ...detail }))
                .catch(error => {
                    console.log(`âš ï¸ ${item.id} ìƒì„¸ì •ë³´ ì‹¤íŒ¨:`, error.message);
                    return item;
                })
        );
        
        const batchResults = await Promise.all(batchPromises);
        enrichedData.push(...batchResults);
        
        console.log(`ğŸ“Š ${type} ë°°ì¹˜ ${Math.floor(i/3) + 1} ì™„ë£Œ (${enrichedData.length}/${dataArray.length})`);
        
        await sleep(600); // ì•ˆì „í•œ ë”œë ˆì´
    }
    
    return enrichedData;
}

// === íƒ€ì…ë³„ ìƒì„¸ì •ë³´ ìˆ˜ì§‘ ===
async function getTypeSpecificDetailInfo(apiKey, item, type) {
    try {
        // ê¸°ë³¸ ìƒì„¸ì •ë³´
        const commonDetail = await getDetailCommon(apiKey, item.id, item.contentTypeId);
        
        // íƒ€ì…ë³„ ì¶”ê°€ ìƒì„¸ì •ë³´
        let specificDetail = {};
        
        switch (type) {
            case 'festivals':
                specificDetail = await getFestivalDetailInfo(apiKey, item.id);
                break;
            case 'accommodation':
                specificDetail = await getAccommodationDetailInfo(apiKey, item.id);
                break;
            case 'restaurants':
                specificDetail = await getRestaurantDetailInfo(apiKey, item.id);
                break;
            case 'culture':
                specificDetail = await getCultureDetailInfo(apiKey, item.id);
                break;
        }
        
        return {
            ...commonDetail,
            ...specificDetail,
            hasDetailInfo: true
        };
        
    } catch (error) {
        return { hasDetailInfo: false };
    }
}

// === ê¸°ë³¸ ìƒì„¸ì •ë³´ ===
async function getDetailCommon(apiKey, contentId, contentTypeId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailCommon2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: contentTypeId,
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json',
            defaultYN: 'Y',
            firstImageYN: 'Y',
            areacodeYN: 'Y',
            catcodeYN: 'Y',
            addrinfoYN: 'Y',
            mapinfoYN: 'Y',
            overviewYN: 'Y'
        });

        const response = await fetch(`${url}?${params.toString()}`, {
            timeout: 8000
        });

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        homepage: itemData.homepage || '',
                        overview: itemData.overview || '',
                        zipcode: itemData.zipcode || '',
                        addr2: itemData.addr2 || '',
                        booktour: itemData.booktour || '',
                        cat1: itemData.cat1 || '',
                        cat2: itemData.cat2 || '',
                        cat3: itemData.cat3 || ''
                    };
                }
            }
        }
        
        return {};
        
    } catch (error) {
        return {};
    }
}

// === ì¶•ì œ ìƒì„¸ì •ë³´ ===
async function getFestivalDetailInfo(apiKey, contentId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailIntro2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: '15',
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json'
        });

        const response = await fetch(`${url}?${params.toString()}`);

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        sponsor1: itemData.sponsor1 || '',
                        sponsor1tel: itemData.sponsor1tel || '',
                        sponsor2: itemData.sponsor2 || '',
                        sponsor2tel: itemData.sponsor2tel || '',
                        eventplace: itemData.eventplace || '',
                        eventhomepage: itemData.eventhomepage || '',
                        agelimit: itemData.agelimit || '',
                        bookingplace: itemData.bookingplace || '',
                        placeinfo: itemData.placeinfo || '',
                        playtime: itemData.playtime || '',
                        program: itemData.program || '',
                        spendtimefestival: itemData.spendtimefestival || '',
                        usetimefestival: itemData.usetimefestival || '',
                        usefee: itemData.usefee || ''
                    };
                }
            }
        }
        
        return {};
        
    } catch (error) {
        return {};
    }
}

// === ìˆ™ë°• ìƒì„¸ì •ë³´ ===
async function getAccommodationDetailInfo(apiKey, contentId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailIntro2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: '32',
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json'
        });

        const response = await fetch(`${url}?${params.toString()}`);

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        accomcount: itemData.accomcount || '',
                        checkintime: itemData.checkintime || '',
                        checkouttime: itemData.checkouttime || '',
                        chkcooking: itemData.chkcooking || '',
                        foodplace: itemData.foodplace || '',
                        infocenterlodging: itemData.infocenterlodging || '',
                        parkinglodging: itemData.parkinglodging || '',
                        pickup: itemData.pickup || '',
                        roomcount: itemData.roomcount || '',
                        reservationurl: itemData.reservationurl || '',
                        subfacility: itemData.subfacility || '',
                        refundregulation: itemData.refundregulation || ''
                    };
                }
            }
        }
        
        return {};
        
    } catch (error) {
        return {};
    }
}

// === ìŒì‹ì  ìƒì„¸ì •ë³´ ===
async function getRestaurantDetailInfo(apiKey, contentId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailIntro2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: '39',
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json'
        });

        const response = await fetch(`${url}?${params.toString()}`);

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        chkcreditcardfood: itemData.chkcreditcardfood || '',
                        discountinfofood: itemData.discountinfofood || '',
                        firstmenu: itemData.firstmenu || '',
                        infocenterfood: itemData.infocenterfood || '',
                        kidsfacility: itemData.kidsfacility || '',
                        opendatefood: itemData.opendatefood || '',
                        opentimefood: itemData.opentimefood || '',
                        parkingfood: itemData.parkingfood || '',
                        reservationfood: itemData.reservationfood || '',
                        restdatefood: itemData.restdatefood || '',
                        scalefood: itemData.scalefood || '',
                        seat: itemData.seat || '',
                        treatmenu: itemData.treatmenu || '',
                        lcnsno: itemData.lcnsno || ''
                    };
                }
            }
        }
        
        return {};
        
    } catch (error) {
        return {};
    }
}

// === ë¬¸í™”ì‹œì„¤ ìƒì„¸ì •ë³´ ===
async function getCultureDetailInfo(apiKey, contentId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailIntro2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: '14',
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json'
        });

        const response = await fetch(`${url}?${params.toString()}`);

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        accomcountculture: itemData.accomcountculture || '',
                        chkbabycarriageculture: itemData.chkbabycarriageculture || '',
                        chkcreditcardculture: itemData.chkcreditcardculture || '',
                        chkpetculture: itemData.chkpetculture || '',
                        discountinfo: itemData.discountinfo || '',
                        infocenterculture: itemData.infocenterculture || '',
                        parkingculture: itemData.parkingculture || '',
                        parkingfee: itemData.parkingfee || '',
                        restdateculture: itemData.restdateculture || '',
                        usefee: itemData.usefee || '',
                        usetimeculture: itemData.usetimeculture || '',
                        scale: itemData.scale || '',
                        spendtime: itemData.spendtime || ''
                    };
                }
            }
        }
        
        return {};
        
    } catch (error) {
        return {};
    }
}

// === ë­í‚¹ ê³„ì‚° (íƒ€ì…ë³„ íŠ¹í™”) ===
function calculateRankings(dataArray, type) {
    return dataArray.map((item, index) => {
        let score = 0;
        
        // ê³µí†µ ì ìˆ˜
        if (item.image) score += 15;
        if (item.tel && item.tel !== '') score += 10;
        if (item.homepage && item.homepage !== '') score += 10;
        if (item.overview && item.overview !== '') score += 15;
        
        // íƒ€ì…ë³„ íŠ¹í™” ì ìˆ˜
        switch (type) {
            case 'festivals':
                if (item.eventStartDate && item.eventEndDate) score += 20;
                if (item.status === 'ongoing') score += 15;
                if (item.sponsor1tel) score += 10;
                if (item.program) score += 10;
                if (item.eventhomepage) score += 5;
                break;
                
            case 'accommodation':
                if (item.checkintime && item.checkouttime) score += 15;
                if (item.reservationurl) score += 10;
                if (item.roomcount) score += 5;
                if (item.goodstay === 'Y' || item.benikia === 'Y' || item.hanok === 'Y') score += 20;
                if (item.parkinglodging) score += 5;
                break;
                
            case 'restaurants':
                if (item.treatmenu) score += 15;
                if (item.firstmenu) score += 10;
                if (item.opentimefood) score += 10;
                if (item.chkcreditcardfood === 'Y') score += 5;
                if (item.parkingfood) score += 5;
                break;
                
            case 'culture':
                if (item.usefee) score += 10;
                if (item.usetimeculture) score += 10;
                if (item.scale) score += 5;
                if (item.parkingculture) score += 5;
                break;

            case 'attractions':
                if (item.heritage1 || item.heritage2 || item.heritage3) score += 20;
                break;
        }
        
        // ìµœê·¼ ìˆ˜ì •ì¼ ê¸°ì¤€
        if (item.modifiedtime) {
            const modifiedDate = new Date(item.modifiedtime);
            const daysDiff = (Date.now() - modifiedDate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysDiff < 30) score += 20;
            else if (daysDiff < 90) score += 15;
            else if (daysDiff < 365) score += 10;
        }
        
        // ì§€ë„ ì •í™•ë„
        const mlevel = parseInt(item.mlevel) || 5;
        score += Math.max(0, 15 - mlevel * 3);
        
        return {
            ...item,
            ranking: {
                score: score,
                rank: 0,
                hasImage: !!item.image,
                hasContact: !!(item.tel && item.tel !== ''),
                hasHomepage: !!(item.homepage && item.homepage !== ''),
                hasDetail: !!item.hasDetailInfo,
                dataQuality: score >= 60 ? 'high' : score >= 40 ? 'medium' : 'low',
                typeSpecificScore: getTypeSpecificScore(item, type)
            }
        };
    })
    .sort((a, b) => b.ranking.score - a.ranking.score)
    .map((item, index) => ({
        ...item,
        ranking: {
            ...item.ranking,
            rank: index + 1
        }
    }));
}

// === ì—°ê´€ ì¶”ì²œ ì‹œìŠ¤í…œ ===
async function getCrossRecommendations(apiKey, region, baseType, baseData, radius) {
    try {
        console.log(`ğŸ”— ${baseType} ê¸°ë°˜ ì—°ê´€ ì¶”ì²œ ì‹œì‘...`);
        
        const recommendations = {
            nearby: {},
            popular: {}
        };
        
        // ìƒìœ„ ë­í‚¹ ì¥ì†Œë“¤ ì¶”ì¶œ
        const topLocations = baseData
            .filter(item => item.mapx && item.mapy && item.ranking?.rank <= 5)
            .slice(0, 3);
        
        if (topLocations.length === 0) {
            return recommendations;
        }
        
        // íƒ€ì…ë³„ ì¶”ì²œ ë¡œì§
        const recommendTypes = getRecommendationTypes(baseType);
        
        for (const recommendType of recommendTypes) {
            console.log(`ğŸ¯ ${recommendType} ì¶”ì²œ ìˆ˜ì§‘...`);
            
            const nearbyItems = await collectTourismData(apiKey, region, recommendType, 20);
            
            if (nearbyItems.success && nearbyItems.data.length > 0) {
                const rankedItems = calculateRankings(nearbyItems.data, recommendType);
                recommendations.nearby[recommendType] = rankedItems.slice(0, 10);
                recommendations.popular[recommendType] = rankedItems
                    .filter(item => item.ranking.dataQuality === 'high')
                    .slice(0, 5);
            }
            
            await sleep(400);
        }
        
        return recommendations;
        
    } catch (error) {
        console.error('âŒ ì—°ê´€ ì¶”ì²œ ì˜¤ë¥˜:', error);
        return { nearby: {}, popular: {} };
    }
}

// === ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤ ===

function getContentTypeName(contentTypeId) {
    const typeMap = {
        '15': 'festivals',
        '12': 'attractions', 
        '32': 'accommodation',
        '39': 'restaurants',
        '14': 'culture',
        '28': 'activities',
        '38': 'shopping'
    };
    return typeMap[contentTypeId] || 'unknown';
}

function getAccommodationType(title) {
    for (const [key, value] of Object.entries(ACCOMMODATION_TYPES)) {
        if (title.includes(key)) {
            return value;
        }
    }
    return 'etc';
}

function getFoodType(title, addr) {
    for (const [key, value] of Object.entries(RESTAURANT_TYPES)) {
        if (title.includes(key) || (addr && addr.includes(key))) {
            return value;
        }
    }
    return 'etc';
}

function calculateEventStatus(startDate, endDate) {
    if (!startDate || !endDate) return 'unknown';
    
    try {
        const now = new Date();
        const start = new Date(startDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        const end = new Date(endDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        
        if (now < start) return 'upcoming';
        if (now > end) return 'ended';
        return 'ongoing';
    } catch (error) {
        return 'unknown';
    }
}

function calculateDaysLeft(startDate, endDate) {
    if (!startDate || !endDate) return 'ë‚ ì§œ ë¯¸ì •';
    
    try {
        const now = new Date();
        const start = new Date(startDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        const end = new Date(endDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        
        if (now < start) {
            const diff = Math.ceil((start - now) / (1000 * 60 * 60 * 24));
            return `${diff}ì¼ í›„ ì‹œì‘`;
        }
        if (now > end) {
            return 'ì¢…ë£Œë¨';
        }
        const diff = Math.ceil((end - now) / (1000 * 60 * 60 * 24));
        return `${diff}ì¼ ë‚¨ìŒ`;
    } catch (error) {
        return 'ë‚ ì§œ ë¯¸ì •';
    }
}

function checkIfWeekend(startDate, endDate) {
    if (!startDate || !endDate) return false;
    
    try {
        const start = new Date(startDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        const end = new Date(endDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        
        // í† ìš”ì¼(6) ë˜ëŠ” ì¼ìš”ì¼(0)ì— ê²¹ì¹˜ëŠ”ì§€ í™•ì¸
        for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
            if (d.getDay() === 0 || d.getDay() === 6) {
                return true;
            }
        }
        return false;
    } catch (error) {
        return false;
    }
}

function getRecommendationTypes(baseType) {
    const typeMap = {
        'festivals': ['accommodation', 'restaurants', 'culture'],
        'accommodation': ['attractions', 'restaurants', 'festivals'],
        'restaurants': ['attractions', 'accommodation', 'culture'],
        'attractions': ['accommodation', 'restaurants', 'festivals'],
        'culture': ['accommodation', 'restaurants', 'festivals'],
        'activities': ['accommodation', 'restaurants']
    };
    return typeMap[baseType] || ['accommodation', 'restaurants'];
}

function getTypeSpecificScore(item, type) {
    switch (type) {
        case 'festivals':
            return {
                hasSchedule: !!(item.eventStartDate && item.eventEndDate),
                hasProgram: !!item.program,
                hasContact: !!item.sponsor1tel,
                hasHomepage: !!item.eventhomepage
            };
        case 'accommodation':
            return {
                hasCertification: item.goodstay === 'Y' || item.benikia === 'Y' || item.hanok === 'Y',
                hasReservation: !!item.reservationurl,
                hasRoomInfo: !!item.roomcount,
                hasCheckinInfo: !!(item.checkintime && item.checkouttime)
            };
        case 'restaurants':
            return {
                hasMenu: !!item.treatmenu,
                hasOperatingHours: !!item.opentimefood,
                acceptsCard: item.chkcreditcardfood === 'Y',
                hasParking: !!item.parkingfood
            };
        case 'culture':
            return {
                hasFeeInfo: !!item.usefee,
                hasOperatingHours: !!item.usetimeculture,
                hasScale: !!item.scale,
                hasParking: !!item.parkingculture
            };
        default:
            return {};
    }
}

function getTotalCount(result) {
    let total = 0;
    for (const key in result) {
        if (Array.isArray(result[key])) {
            total += result[key].length;
        } else if (typeof result[key] === 'object' && result[key] !== null) {
            // ì¤‘ì²©ëœ ê°ì²´ì˜ ê²½ìš° (recommendations ë“±)
            for (const subKey in result[key]) {
                if (Array.isArray(result[key][subKey])) {
                    total += result[key][subKey].length;
                }
            }
        }
    }
    return total;
}

function getRegionFromAddr(addr) {
    if (!addr) return 'ê¸°íƒ€';
    
    const regions = Object.keys(AREA_CODES);
    for (const region of regions) {
        if (addr.includes(region)) {
            return region;
        }
    }
    return 'ê¸°íƒ€';
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
