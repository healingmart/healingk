// api/all_tourism.js

const AREA_CODES = {
    '서울': 1, '부산': 6, '제주': 39, '강릉': 32,
    '전주': 37, '대구': 4, '광주': 5, '대전': 3,
    '인천': 2, '울산': 7, '경주': 35, '춘천': 32
};

const CONTENT_TYPES = {
    festivals: 15,      // 축제공연행사
    attractions: 12,    // 관광지
    accommodation: 32,  // 숙박
    restaurants: 39,    // 음식점
    culture: 14,        // 문화시설
    activities: 28,     // 레포츠
    shopping: 38,       // 쇼핑
    all: 'all'
};

module.exports = async function handler(req, res) {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');

    if (req.method === 'OPTIONS') {
        return res.status(200).end();
    }

    try {
        const startTime = Date.now();
        const { 
            region = '서울', 
            type = 'festivals', 
            detail = 'basic',
            ranking = 'true',
            numOfRows = 50 
        } = req.query;

        console.log('🚀 === ALL TOURISM API 시작 ===');
        console.log(`📍 지역: ${region}`);
        console.log(`🏷️ 타입: ${type}`);
        console.log(`📊 상세도: ${detail}`);

        // API 키 확인
        const possibleKeys = [
            process.env.JEONBUK_API_KEY,
            process.env.TOURISM_API_KEY,
            process.env.TOUR_API_KEY,
            process.env.WEATHER_API_KEY,
            process.env.REGIONAL_API_KEY
        ];

        const apiKey = possibleKeys.find(key => key);
        
        if (!apiKey) {
            console.log('❌ API 키 없음');
            return res.status(200).json({
                success: false,
                message: 'API 키가 설정되지 않았습니다',
                data: {},
                responseTime: `${Date.now() - startTime}ms`
            });
        }

        console.log('✅ API 키 확인:', `${apiKey.substring(0, 10)}...`);

        let result = {};

        // 전체 타입 요청
        if (type === 'all') {
            console.log('🌐 전체 타입 데이터 수집...');
            result = await collectAllTypesData(apiKey, region, detail, ranking, parseInt(numOfRows));
        } else {
            // 단일 타입 요청
            const singleTypeData = await collectTourismData(apiKey, region, type, parseInt(numOfRows));
            
            if (!singleTypeData.success) {
                throw new Error(singleTypeData.error || '데이터 수집 실패');
            }

            let processedData = singleTypeData.data;

            // 상세정보 수집
            if (detail === 'full' && processedData.length > 0) {
                console.log('📋 상세정보 수집 시작...');
                processedData = await enrichWithDetailInfo(apiKey, processedData, type);
            }

            // 랭킹 계산
            if (ranking === 'true' && processedData.length > 0) {
                console.log('🏆 랭킹 계산 시작...');
                processedData = calculateRankings(processedData, type);
            }

            result[type] = processedData;
        }

        const responseTime = Date.now() - startTime;

        return res.status(200).json({
            success: true,
            data: result,
            meta: {
                region: region,
                type: type,
                detailLevel: detail,
                hasRanking: ranking === 'true',
                totalCount: getTotalCount(result),
                responseTime: `${responseTime}ms`,
                timestamp: new Date().toISOString()
            },
            message: `✅ ${region} ${type} 정보 ${getTotalCount(result)}개 수집 완료`
        });

    } catch (error) {
        console.error('❌ ALL TOURISM API 오류:', error);
        return res.status(500).json({
            success: false,
            error: error.message,
            message: '관광 정보 수집 중 오류가 발생했습니다',
            timestamp: new Date().toISOString()
        });
    }
};

// === 전체 타입 데이터 수집 ===
async function collectAllTypesData(apiKey, region, detail, ranking, numOfRows) {
    const types = ['festivals', 'attractions', 'accommodation', 'restaurants', 'culture'];
    const result = {};
    const itemsPerType = Math.floor(numOfRows / types.length);
    
    for (const type of types) {
        try {
            console.log(`🔄 ${type} 데이터 수집 중...`);
            
            const typeData = await collectTourismData(apiKey, region, type, itemsPerType);
            
            if (typeData.success && typeData.data.length > 0) {
                let processedData = typeData.data;
                
                // 상세정보 수집
                if (detail === 'full') {
                    processedData = await enrichWithDetailInfo(apiKey, processedData, type);
                }
                
                // 랭킹 계산
                if (ranking === 'true') {
                    processedData = calculateRankings(processedData, type);
                }
                
                result[type] = processedData;
                console.log(`✅ ${type}: ${processedData.length}개 수집 완료`);
            } else {
                result[type] = [];
                console.log(`⚠️ ${type}: 데이터 없음`);
            }
            
            // 타입 간 딜레이
            await sleep(300);
            
        } catch (error) {
            console.error(`❌ ${type} 수집 오류:`, error);
            result[type] = [];
        }
    }
    
    return result;
}

// === 관광 데이터 수집 ===
async function collectTourismData(apiKey, region, type, numOfRows) {
    try {
        const areaCode = AREA_CODES[region] || 1;
        const contentTypeId = CONTENT_TYPES[type];

        if (!contentTypeId || contentTypeId === 'all') {
            throw new Error('올바르지 않은 타입');
        }

        console.log(`🔍 ${region} (${areaCode}) ${type} (${contentTypeId}) 데이터 수집...`);

        const allData = [];
        const maxPages = Math.ceil(numOfRows / 100);

        for (let page = 1; page <= Math.min(maxPages, 3); page++) {
            console.log(`📄 ${type} 페이지 ${page} 수집 중...`);
            
            const pageData = await fetchTourismPage(apiKey, {
                areaCode,
                contentTypeId,
                numOfRows: Math.min(100, numOfRows),
                pageNo: page
            });

            if (pageData.success && pageData.data.length > 0) {
                allData.push(...pageData.data);
                console.log(`✅ ${type} 페이지 ${page}: ${pageData.data.length}개 수집`);
                
                if (pageData.data.length < 100 || allData.length >= numOfRows) {
                    break;
                }
            } else {
                console.log(`❌ ${type} 페이지 ${page} 수집 실패`);
                break;
            }

            await sleep(200);
        }

        console.log(`🎯 ${type} 총 ${allData.length}개 데이터 수집 완료`);

        return {
            success: true,
            data: allData.slice(0, numOfRows) // 요청한 개수만큼만
        };

    } catch (error) {
        console.error(`❌ ${type} 데이터 수집 오류:`, error);
        return {
            success: false,
            error: error.message
        };
    }
}

// === 개별 페이지 데이터 수집 ===
async function fetchTourismPage(apiKey, params) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/areaBasedList2';
        const queryParams = new URLSearchParams({
            serviceKey: apiKey,
            numOfRows: params.numOfRows,
            pageNo: params.pageNo,
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json',
            contentTypeId: params.contentTypeId,
            areaCode: params.areaCode,
            arrange: 'D' // 수정일순
        });

        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const response = await fetch(`${url}?${queryParams.toString()}`, {
            method: 'GET',
            headers: {
                'Accept': 'application/json',
                'User-Agent': 'HealingK-Tourism/1.0'
            },
            signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
            throw new Error(`HTTP ${response.status}`);
        }

        const data = await response.json();
        
        if (data.response?.header?.resultCode === '0000') {
            const items = data.response.body?.items?.item || [];
            const itemsArray = Array.isArray(items) ? items : [items];
            
            return {
                success: true,
                data: itemsArray.map(item => transformTourismData(item, params.contentTypeId))
            };
        } else {
            throw new Error(data.response?.header?.resultMsg || '데이터 없음');
        }

    } catch (error) {
        return {
            success: false,
            error: error.message
        };
    }
}

// === 관광 데이터 변환 ===
function transformTourismData(item, contentTypeId) {
    const baseData = {
        id: item.contentid,
        title: item.title || '제목 없음',
        location: item.addr1 || '주소 없음',
        region: getRegionFromAddr(item.addr1),
        tel: item.tel || '',
        contentTypeId: contentTypeId,
        contentType: getContentTypeName(contentTypeId),
        mapx: item.mapx,
        mapy: item.mapy,
        image: item.firstimage || null,
        thumbnail: item.firstimage2 || null,
        createdtime: item.createdtime,
        modifiedtime: item.modifiedtime,
        mlevel: item.mlevel || '1',
        areacode: item.areacode,
        sigungucode: item.sigungucode,
        originalData: {
            source: 'korean_tourism_organization',
            contentType: getContentTypeName(contentTypeId),
            isRealData: true
        }
    };

    // 타입별 특화 데이터 추가
    switch (contentTypeId) {
        case '15': // 축제
            return {
                ...baseData,
                category: 'festivals',
                eventStartDate: item.eventstartdate || '',
                eventEndDate: item.eventenddate || '',
                status: calculateEventStatus(item.eventstartdate, item.eventenddate),
                daysLeft: calculateDaysLeft(item.eventstartdate, item.eventenddate)
            };

        case '32': // 숙박
            return {
                ...baseData,
                category: 'accommodation',
                accommodationType: getAccommodationType(item.title)
            };

        case '39': // 음식점
            return {
                ...baseData,
                category: 'restaurants',
                foodType: getFoodType(item.title)
            };

        default:
            return {
                ...baseData,
                category: getContentTypeName(contentTypeId)
            };
    }
}

// === 상세정보 수집 ===
async function enrichWithDetailInfo(apiKey, dataArray, type) {
    console.log(`📋 ${type} ${dataArray.length}개 항목의 상세정보 수집...`);
    
    const enrichedData = [];
    
    // 배치 처리 (5개씩 - 안전하게)
    for (let i = 0; i < dataArray.length; i += 5) {
        const batch = dataArray.slice(i, i + 5);
        
        const batchPromises = batch.map(item => 
            getDetailInfo(apiKey, item.id, item.contentTypeId)
                .then(detail => ({ ...item, ...detail }))
                .catch(error => {
                    console.log(`⚠️ ${item.id} 상세정보 실패:`, error.message);
                    return item;
                })
        );
        
        const batchResults = await Promise.all(batchPromises);
        enrichedData.push(...batchResults);
        
        console.log(`📊 ${type} 배치 ${Math.floor(i/5) + 1} 완료 (${enrichedData.length}/${dataArray.length})`);
        
        await sleep(500); // 안전한 딜레이
    }
    
    return enrichedData;
}

// === 개별 상세정보 수집 ===
async function getDetailInfo(apiKey, contentId, contentTypeId) {
    try {
        const url = 'https://apis.data.go.kr/B551011/KorService2/detailCommon2';
        const params = new URLSearchParams({
            serviceKey: apiKey,
            contentId: contentId,
            contentTypeId: contentTypeId,
            MobileOS: 'ETC',
            MobileApp: 'HealingK',
            _type: 'json',
            defaultYN: 'Y',
            firstImageYN: 'Y',
            areacodeYN: 'Y',
            catcodeYN: 'Y',
            addrinfoYN: 'Y',
            mapinfoYN: 'Y',
            overviewYN: 'Y'
        });

        const response = await fetch(`${url}?${params.toString()}`, {
            timeout: 8000
        });

        if (response.ok) {
            const data = await response.json();
            
            if (data.response?.header?.resultCode === '0000') {
                const item = data.response.body?.items?.item;
                const itemData = Array.isArray(item) ? item[0] : item;
                
                if (itemData) {
                    return {
                        homepage: itemData.homepage || '',
                        overview: itemData.overview || '',
                        zipcode: itemData.zipcode || '',
                        addr2: itemData.addr2 || '',
                        cat1: itemData.cat1 || '',
                        cat2: itemData.cat2 || '',
                        cat3: itemData.cat3 || '',
                        hasDetailInfo: true
                    };
                }
            }
        }
        
        return { hasDetailInfo: false };
        
    } catch (error) {
        return { hasDetailInfo: false };
    }
}

// === 랭킹 계산 ===
function calculateRankings(dataArray, type) {
    return dataArray.map((item, index) => {
        let score = 0;
        
        // 공통 점수
        if (item.image) score += 15;
        if (item.tel && item.tel !== '') score += 10;
        if (item.homepage && item.homepage !== '') score += 10;
        if (item.overview && item.overview !== '') score += 15;
        
        // 타입별 특화 점수
        switch (type) {
            case 'festivals':
                if (item.eventStartDate && item.eventEndDate) score += 20;
                if (item.status === 'ongoing') score += 10;
                break;
                
            case 'accommodation':
                if (item.tel && item.tel !== '') score += 15;
                break;
                
            case 'restaurants':
                if (item.tel && item.tel !== '') score += 15;
                break;
        }
        
        // 최근 수정일 기준
        if (item.modifiedtime) {
            const modifiedDate = new Date(item.modifiedtime);
            const daysDiff = (Date.now() - modifiedDate.getTime()) / (1000 * 60 * 60 * 24);
            if (daysDiff < 30) score += 20;
            else if (daysDiff < 90) score += 15;
            else if (daysDiff < 365) score += 10;
        }
        
        // 지도 정확도
        const mlevel = parseInt(item.mlevel) || 5;
        score += Math.max(0, 15 - mlevel * 3);
        
        return {
            ...item,
            ranking: {
                score: score,
                rank: 0,
                hasImage: !!item.image,
                hasContact: !!(item.tel && item.tel !== ''),
                hasHomepage: !!(item.homepage && item.homepage !== ''),
                hasDetail: !!item.hasDetailInfo,
                dataQuality: score >= 50 ? 'high' : score >= 30 ? 'medium' : 'low'
            }
        };
    })
    .sort((a, b) => b.ranking.score - a.ranking.score)
    .map((item, index) => ({
        ...item,
        ranking: {
            ...item.ranking,
            rank: index + 1
        }
    }));
}

// === 유틸리티 함수들 ===

function getContentTypeName(contentTypeId) {
    const typeMap = {
        '15': 'festivals',
        '12': 'attractions', 
        '32': 'accommodation',
        '39': 'restaurants',
        '14': 'culture',
        '28': 'activities',
        '38': 'shopping'
    };
    return typeMap[contentTypeId] || 'unknown';
}

function getAccommodationType(title) {
    if (title.includes('호텔')) return 'hotel';
    if (title.includes('펜션')) return 'pension';
    if (title.includes('모텔')) return 'motel';
    if (title.includes('리조트')) return 'resort';
    if (title.includes('한옥')) return 'hanok';
    return 'etc';
}

function getFoodType(title) {
    if (title.includes('한식') || title.includes('갈비') || title.includes('불고기')) return 'korean';
    if (title.includes('중식') || title.includes('중국')) return 'chinese';
    if (title.includes('일식') || title.includes('초밥') || title.includes('라멘')) return 'japanese';
    if (title.includes('양식') || title.includes('스테이크') || title.includes('파스타')) return 'western';
    if (title.includes('카페') || title.includes('커피')) return 'cafe';
    return 'etc';
}

function calculateEventStatus(startDate, endDate) {
    if (!startDate || !endDate) return 'unknown';
    
    try {
        const now = new Date();
        const start = new Date(startDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        const end = new Date(endDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        
        if (now < start) return 'upcoming';
        if (now > end) return 'ended';
        return 'ongoing';
    } catch (error) {
        return 'unknown';
    }
}

function calculateDaysLeft(startDate, endDate) {
    if (!startDate || !endDate) return '날짜 미정';
    
    try {
        const now = new Date();
        const start = new Date(startDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        const end = new Date(endDate.replace(/(\d{4})(\d{2})(\d{2})/, '$1-$2-$3'));
        
        if (now < start) {
            const diff = Math.ceil((start - now) / (1000 * 60 * 60 * 24));
            return `${diff}일 후 시작`;
        }
        if (now > end) {
            return '종료됨';
        }
        const diff = Math.ceil((end - now) / (1000 * 60 * 60 * 24));
        return `${diff}일 남음`;
    } catch (error) {
        return '날짜 미정';
    }
}

function getTotalCount(result) {
    let total = 0;
    for (const key in result) {
        if (Array.isArray(result[key])) {
            total += result[key].length;
        }
    }
    return total;
}

function getRegionFromAddr(addr) {
    if (!addr) return '기타';
    
    const regions = Object.keys(AREA_CODES);
    for (const region of regions) {
        if (addr.includes(region)) {
            return region;
        }
    }
    return '기타';
}

function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
